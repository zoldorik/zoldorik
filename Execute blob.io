1-const canvas = 2-document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); canvas.width = 800; canvas.height = 600; // Classe Blob class'gameCanvas'); const ctx = canvas.getContext('2d'); canvas.width = 800; canvas.height = 600; // Classe Blob class'gameCanvas'); const ctx = canvas.getContext('2d'); canvas.width = 800; canvas.height = 600; // Classe Blob classe Blob { construtor(x, y, tamanho, cor) { this.x = x; this.y = y; this.size = tamanho; this.color = cor; this.speed = 1       + Math.random(); // velocidade variável this.target = nulo; // Método para desenhar o blob draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.size,       0, Math. PI * 2); ctx.fillStyle = this.color; ctx.fill(); } // Método para mover o blob mcanvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); canvas.width = 800; canvas.height = 600; // Classe Blob classe Blob { construtor(x, y, tamanho, cor) { this.x = x; this.y = y; this.size = tamanho; this.color = cor; this.speed = 1       + Math.random(); // velocidade variável this.target = nulo; // Método para desenhar o blob draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.size,       0, Math. PI * 2); ctx.fillStyle = this.color; ctx.fill(); } // Método para mover o blob me Blob { construtor(x, y, tamanho, cor) { this.x = x; this.y = y; this.size = tamanho; this.color = cor; this.speed = 1       + Math.random(); // velocidade variável this.target = nulo; // Método para desenhar o blob draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.size,       0, Math. PI * 2); ctx.fillStyle = this.color; ctx.fill(); } // Método para mover o blob move() { se (this.target) { const dx = this.target.x - this.x; const dy = this.target.y - this.y; const dist = Math.hypot(dx, dy); se (dist > 1) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; } } else       { // Movimento aleatório this.x += (Math.random() -       0.5) * this.speed * 2; this.y += (Math.random() - 0.5) * this.speed * 2; } / Limitar dentro do canvas this.x.max (this.s,,, this.size, this.speed * 2; this.y += (Math.y += (Math.random() - 0.5) * this.random() - 0.5) * this.speed;) this.speed().speed) PI * 2); ctx.fillStyle = this.color; ctx.fill(); } // Método para mover o blob move() { se (this.target) { const dx = this.target.x - this.x; const dy = this.target.y - this.y; const dist = Math.hypot(dx, dy); se (dist > 1) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; } } else       { // Movimento aleatório this.x += (Math.random() -       0.5) * this.speed * 2; this.y += (Math.random() - 0.5) * this.speed * 2; } / Limitar dentro do canvas this.x.max (this.s,,, this.size, this.speed * 2; this.y += (Math.y += (Math.random() - 0.5) * this.random() - 0.5) * this.speed;) this.speed().speed) PI * 2); ctx.fillStyle = this.color; ctx.fill(); } // Método para mover o blob move() { se (this.target) { const dx = this.target.x - this.x; const dy = this.target.y - this.y; const dist = Math.hypot(dx, dy); se (dist > 1) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; } } else       { // Movimento aleatório this.x += (Math.random() -       0.5) * this.speed * 2; this.y += (Math.random() - 0.5) * this.speed * 2; } / Limitar dentro do canvas this.x.max (this.s,,, this.size, this.speed * 2; this.y += (Math.y += (Math.random() - 0.5) * this.random() - 0.5) * this.speed;) this.speed().speed) layer); // Movimento do jogador com o mouse canvas.addEventListener('mousemove', (e) => { player.target = { x: e.offsetX, y: e.offsetYove() { if (this.target) { const dx = this.target.x - this.x; const dy = this.target.y - this.y; const dist = Math.hypot(dx, dy); if (dist > 1) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; } } else       { // Movimento aleatório this.x += (Math.random() -       0.5) * this.speed * 2; this.y += (Math.random() - 0.5) * this.speed * 2ove() { se (this.target) { const dx = this.target.x - this.x; const dy = this.target.y - this.y; const dist = Math.hypot(dx, dy); se (dist > 1) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; } } else      { // Movimento aleatório this.x += (Math.random() -      0.5) * this.speed * 2; this.y += (Math.random() - 0.5) * this.speed * 2; } // Limitar dentro do canvas this.x = Math.max(this.size, Math.min(canvas.width - this.x)); this.y = Math.max(this.max(this.size, this.x) Math.min (canvas.height - this.size, this.y)); } // Verificar se pode comer outro blob canEat(other) { return this.size > other.size * 1.2 && this.isNear(other); } // Verificar se está perto de outro blob isNear(other) { const dist = Math.hypot(this.x - other.x, this.y - other.y); return dist < this.size + other.size; } // Aumentar tamanho ao comer(other) { this.size += other.size * 0.2   ; // crescer proporcional other.size =     0   ; // o outro desaparece } // Criar múltiplas blobs (incluindo bots) const blobs = []; cores const =     1.2 && this.isNear(other); } // Verificar se está perto de outro blob isNear(other) { const dist = Math.hypot(this.x - other.x, this.y - other.y); return dist < this.size + other.size; } // Aumentar tamanho ao comer eat(other) { this.size += other.size * 0.2     ; // crescimento proporcional other.size =       0; // o outro desaparece } } // Criar múltiplos blobs (incluindo bots) const blobs = []; const colors =  ['red', 'blue', 'green', 'orange', 'purple', 'pink', 'cyan', 'magenta']; for (let i = 0; i < 6; i++) { blobs.push(new Blob( Math.random() * (canvas.width - 20) + 10, Math.random() * (canvas.height - 20) + 10, 10 + Math.random() * 10, colors[i]     )); } // Blob controlado pelo usuário const player = new Blob(canvas.width /     2, canvas.height / 2, 15, 'black'); blobs.push(player); // Movimento do jogador com o mouse canvas.addEventListener('mousemove', (e) => { player.target = { x: e.offsetX, y: e.offsetY2, canvas.height / 2, 15, 'black'); blobs.push(player); // Movimento do jogador com o mouse canvas.addEventListener('mousemove', (e) => { player.target = { x: e.offsetX, y: e.offsetY